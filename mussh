#!/usr/bin/env bash
#
# $Id: mussh,v 1.12 2006/12/26 21:57:22 doughnut Exp $
MUSSH_VERSION="1.1"

# Enable some Bash safety features
set -o pipefail  # Fail if any command in a pipe fails
IFS=$' \t\n'     # Reset IFS to standard value
#
# Description:  This script is used to execute the same command(s) on
#               many hosts.
#
# by doughnut




########################
# INITIALIZE THIS CRAP #
########################
DEBUG=0
SSH_VERBOSE=""
QUIET=0
FORCE_AGENT=0
UNIQUE_HOSTS=1
PROXY_SSH_ARGS="-o PasswordAuthentication=no"
SSH_ARGS="-o BatchMode=yes"
AGENT_LOADED=0
REMOTE_SHELL='bash'
TEMP_BASE=/tmp
CONCURRENT=1
JUMP_HOST=''
SSH_LOG_FILE=''
BIND_INTERFACE=''
CONTROL_MASTER=''
CONTROL_PATH=''
CONTROL_PERSIST=''
IDENTITY_AGENT=''
FORWARD_HOSTPORT=''
HASH_KNOWN_HOSTS=''
VERIFY_HOST_DNS=''

############################
# GOTTA LOVE DOCUMENTATION #
############################
USAGE="Usage: mussh [OPTIONS] <-h host.. | -H hostfile> [-c cmd] [-C scriptfile]
mussh --help        for full help text"
HELPTEXT="
Send a command or list of commands to multiple hosts.

OPTIONS:
        --help          This text.
        -d [n]          Verbose debug.  Prints each action, all hosts
                        and commands to be executed to STDERR.  'n' can
                        be from 0 to 2.
        -v [n]          Ssh debug levels.  Can be from 0 to 3.
        -m [n]          Run concurrently on 'n' hosts at a time (asynchronous).
                        Use '0' (zero) for infinite. (default if -m)
        -q              No output unless necessary. 
        -i <identity> [identity ..]
                        Load an identity file.  May be used
                        more than once.
        -o <ssh-args>   Args to pass to ssh with -o option.
        -a              Force loading ssh-agent.
        -A              Do NOT load ssh-agent.
        -b              Print each hosts' output in a block without mingling
                        with other hosts' output.
        -B              Allow hosts' output to mingle. (default)
        -u              Unique.  Eliminate duplicate hosts. (default)
        -U              Do NOT make host list unique.
        -P              Do NOT fall back to passwords on any host.  This will
                        skip hosts where keys fail.
	-l <login>      Use 'login' when no other is specified with hostname.
	-L <login>      Force use of 'login' name on all hosts.
        -s <shell>      Path to shell on remote host. (Default: $REMOTE_SHELL)
        -t <secs>       Timeout setting for each session.
                        (requires openssh 3.8 or newer)
        -V              Print version info and exit.
        -E <log_file>   Append debug logs to the specified file.
                        (requires openssh 6.7 or newer)
        -B <interface>  Bind to the specified network interface.
                        (requires openssh 6.8 or newer)
        -W <host:port>  Forward standard input and output to the specified host and port.
                        (requires openssh 5.4 or newer)
        -CM             Enable SSH ControlMaster for connection sharing.
                        (requires openssh 4.0 or newer)
        -CP <time>      Keep the master connection open in the background.
                        Example: '10m' for 10 minutes, 'yes' for indefinite.
                        (requires openssh 5.6 or newer)
        -S <path>       Location of ControlPath socket for connection sharing.
                        (requires openssh 4.0 or newer)
        -T <socket>     Specifies the UNIX-domain socket used to communicate with
                        the authentication agent.
                        (requires openssh 7.3 or newer)
        -HKH            Enable HashKnownHosts for better security.
                        (requires openssh 4.0 or newer)
        -VHD            Enable verification of host keys via DNS (VerifyHostKeyDNS=yes).
                        (requires openssh 4.0 or newer)
PROXY ARGS:
        -p [user@]<host>
                        Host to use as proxy.  (Must have mussh installed)
        -po <ssh-args>        Args to pass to ssh on proxy with -o option.
        -J [user@]<host>      Host to use as a jump host (requires openssh 7.3 or newer).
                        Uses ProxyJump SSH option.
HOST ARGS:
        -h [user@]<host> [[user@]<host> ..]
                        Add a host to list of hosts. May be
                        used more than once. Supports wildcards
                        (e.g., server*, *.example.com) which
                        will be expanded using hosts from ~/.ssh/known_hosts
                        and ~/.ssh/config.
        -H <file> [file ..]
                        Add contents of file(s) to list of hosts.
                        Files should have one host per line.  Use
                        \"#\" for comments.
        -n <netgroup>
                        Add hosts from the specified netgroup.
COMMAND ARGS:
If neither is specified, commands will be read from standard input.
        -c <command>    Add a command or quoted list of commands and
                        args to list of commands to be executed on
                        each host.  May be used more than once.
        -C <file> [file ..]
                        Add file contents to list of commands to be
                        executed on each host.  May be used more
                        than once.

At least one host is required.  Arguments are in no particular order.

EXAMPLES:
mussh -H ./linuxhosts -C spfiles/testscript.sh
mussh -c \"cat /etc/hosts\" -h myhost.mydomain.com

Comments and Bug Reports: doughnut@doughnut.net
"

###########################
# FUNCTIONS FOR SSH-AGENT #
###########################
load_keys() {
        [ "$AGENT_LOADED" = "0" -a "$IDENT" = "" ] && return
        [ "$DEBUG" -ge 1 ] && echo "DEBUG: Adding Keys" 1>&2
        ssh-add $* 1>&2
}

start_agent() {
        [ "$DEBUG" -ge 1 ] && echo "DEBUG: Starting Agent" 1>&2
        if [ "$FORCE_AGENT" -ge 1 ] ; then
                # Load it anyway
                [ "$DEBUG" -ge 1 ] && echo "DEBUG: Forcing SSH Agent" 1>&2
        elif [ -S "$SSH_AUTH_SOCK" ] ; then
                [ "$DEBUG" -ge 1 ] && echo "DEBUG: SSH Agent already loaded" 1>&2
                return
        fi
        eval $(ssh-agent -s) >/dev/null
        AGENT_LOADED=1
}
stop_agent() {
        # get rid of the keys that we added (if any)
        if [ "$IDENT" != "" ] ; then
                [ "$DEBUG" -ge 1 ] && echo "DEBUG: Removing keys from agent" 1>&2
                ssh-add -d $IDENT > /dev/null 2>&1
        fi
        [ "$AGENT_LOADED" = "0" ] && return
        [ "$DEBUG" -ge 1 ] && echo "DEBUG: Stopping Agent" 1>&2
	eval $(ssh-agent -s -k) >/dev/null
}

####################################
# FUNCTIONS FOR REMOTE CONNECTIONS #
####################################
proxy_connect() {
        [ "$DEBUG" -ge 1 ] && echo "DEBUG: PROXY CONNECT $PROXY" 1>&2
        
        # Build command options for proxy
        PROXY_CMD="mussh -h $HOSTLIST -C - -d$DEBUG"
        
        # Pass verbose flags properly
        if [ -n "$SSH_VERBOSE" ] && [ "$SSH_VERBOSE" != "-q" ]; then
            # Count the number of -v flags and convert to -v1, -v2, or -v3
            VERBOSE_COUNT=$(echo "$SSH_VERBOSE" | tr -cd 'v' | wc -c)
            PROXY_CMD="$PROXY_CMD -v$VERBOSE_COUNT"
        fi
        
        # Add other proxy args
        PROXY_CMD="$PROXY_CMD $PROXY_SSH_ARGS"
        
        echo "$THESCRIPT" \
                | ssh -T $SSH_ARGS $PROXY \
                        "$PROXY_CMD 2>&1" \
                        | while read SSH_LINE ; do
                            if [ "$QUIET" -lt 1 -a "$SSH_LINE" != "" ] ; then
                                echo "$SSH_LINE" | sed -e "s/^/$HOST: /"
                            fi
                        done
}

ssh_connect() {
	echo "$THESCRIPT" \
	    | ssh -T $SSH_VERBOSE $SSH_ARGS $HOST "$REMOTE_SHELL" 2>&1 \
	    | while read SSH_LINE ; do
		if [ "$QUIET" -lt 1 -a "$SSH_LINE" != "" ] ; then
			echo "$SSH_LINE" | sed -e "s/^/$HOST: /"
		fi
	    done
}

##############################
# FUNCTIONS FOR FORKED PROCS #
##############################
set_hostlist() {
# Create a hostlist file.
	[ "$DEBUG" -ge 2 ] && echo "DEBUG: BUILDING HOST LIST FILE $TEMP_DIR/hostlist" 1>&2
	rm -f $TEMP_DIR/hostlist || exit 1
	for HOST in $HOSTLIST ; do
		echo $HOST >> "$TEMP_DIR/hostlist" || exit 1
	done
}

get_next_host() {
# Use better file locking (mkdir is atomic on most filesystems)
	local lock_dir="$TEMP_DIR/hostlist.lock.d"
	local max_attempts=30
	local attempt=0
	
	while ! mkdir "$lock_dir" 2>/dev/null; do
		attempt=$((attempt + 1))
		if [ $attempt -ge $max_attempts ]; then
			[ "$DEBUG" -ge 1 ] && echo "DEBUG[#$CHILDNUM]: Failed to acquire lock after $max_attempts attempts." 1>&2
			return 1
		fi
		[ "$DEBUG" -ge 2 ] && echo "DEBUG[#$CHILDNUM]: hostlist file already locked. Sleep... (attempt $attempt/$max_attempts)" 1>&2
		sleep 1
	done
	
	# Record which process has the lock for debugging
	echo "$CHILDNUM" > "$lock_dir/owner"
	[ "$DEBUG" -ge 2 ] && echo "DEBUG[#$CHILDNUM]: Locked hostfile." 1>&2

	# get next host if the file exists and has content
	if [ ! -s "$TEMP_DIR/hostlist" ]; then
		[ "$DEBUG" -ge 2 ] && echo "DEBUG[#$CHILDNUM]: Host list empty or missing." 1>&2
		rmdir "$lock_dir" 2>/dev/null || rm -rf "$lock_dir"
		return 1
	fi
	
	# Read first line more efficiently with bash
	IFS= read -r NEXT_HOST < "$TEMP_DIR/hostlist"
	# Count lines more efficiently with bash
	HOSTFILE_LEN=0
	while IFS= read -r line; do
		((HOSTFILE_LEN++))
	done < "$TEMP_DIR/hostlist"
	
	if [ -z "$HOSTFILE_LEN" ] || [ "$HOSTFILE_LEN" -eq 0 ]; then
		[ "$DEBUG" -ge 2 ] && echo "DEBUG[#$CHILDNUM]: Host list is empty." 1>&2
		rmdir "$lock_dir" 2>/dev/null || rm -rf "$lock_dir"
		return 1
	fi
	
	[ "$DEBUG" -ge 2 ] && echo "DEBUG[#$CHILDNUM]: Next host: $NEXT_HOST" 1>&2

	# re-write file removing top host more efficiently with bash
	if [ "$HOSTFILE_LEN" -gt 1 ]; then
		# Skip first line using bash read
		{
			IFS= read -r  # skip first line
			cat  # output remaining lines
		} < "$TEMP_DIR/hostlist" > "$TEMP_DIR/hostlist.new" || exit 1
		mv "$TEMP_DIR/hostlist.new" "$TEMP_DIR/hostlist"
	else
		# If this was the last host, just create an empty file
		> "$TEMP_DIR/hostlist"
	fi

	# unlock file
	[ "$DEBUG" -ge 2 ] && echo "DEBUG[#$CHILDNUM]: Removing hostfile lock." 1>&2
	rmdir "$lock_dir" 2>/dev/null || rm -rf "$lock_dir"

	# return hostname
	echo "$NEXT_HOST"
}

run_child() {
	trap "exit 0" SIGHUP
	CHILDNUM=$1
	[ "$DEBUG" -ge 2 ] && echo "DEBUG: FORKING CHILD #$CHILDNUM of $CONCURRENT (pid $!/$$)" 1>&2
	while [ 1 ] ; do

# issue:  Cannot call get_next_host inside $() or `` because our trap won't be able to kill that.
# solution: avoid subshell here by directing to a file.
		rm -f $TEMP_DIR/$CHILDNUM.next_host
		get_next_host >$TEMP_DIR/$CHILDNUM.next_host
		HOST=$(<$TEMP_DIR/$CHILDNUM.next_host)
		if [ -z "$HOST" ] ; then
			rm -f "$TEMP_DIR/$CHILDNUM.pid"
			break
		fi
		[ "$DEBUG" -ge 1 ] && echo "DEBUG[#$CHILDNUM]: CONNECT $HOST" 1>&2

		rm -f "$TEMP_DIR/$CHILDNUM.active"
		echo "$HOST" > "$TEMP_DIR/$CHILDNUM.active"
		if [ -n "$BLOCKING" ] ; then
			ssh_connect > $TEMP_DIR/$HOST.out 
			cat $TEMP_DIR/$HOST.out 
		else
			ssh_connect
		fi
	done
	[ "$DEBUG" -ge 2 ] && echo "DEBUG: CHILD #$CHILDNUM done" 1>&2
	rm -f "$TEMP_DIR/$CHILDNUM.pid" "$TEMP_DIR/$CHILDNUM.active"
}


###########################
# FUNCTIONS FOR TEMP DIRS #
###########################
create_temp() {
	MKTEMP=$(which mktemp 2>/dev/null)
	if [ -x "$MKTEMP" ] ; then
        	[ "$DEBUG" -ge 2 ] && echo "DEBUG: using mktemp ($MKTEMP)." 1>&2
		TEMP_DIR=$(mktemp -d $TEMP_BASE/$(basename $0).XXXXXX) || exit 1
	else
        	[ "$DEBUG" -ge 2 ] && echo "DEBUG: can't find mktemp... using alternate." 1>&2
        	TEMP_DIR="$TEMP_BASE/$(basename $0).$(date +%s)"
        	[ "$DEBUG" -ge 2 ] && echo "DEBUG: Creating temp dir ($TEMP_DIR)." 1>&2
		if [ -e "$TEMP_DIR" ] ; then
			echo "$0: Temp dir \"$TEMP_DIR\" already exists!" 1>&2
			exit 1
		fi
		mkdir -m 700 $TEMP_DIR
	fi
}

destroy_temp() {
	if [ -d "$TEMP_DIR" ] ; then
        	[ "$DEBUG" -ge 2 ] && echo "DEBUG: Removing temp dir ($TEMP_DIR)." 1>&2
		rm -rf "$TEMP_DIR" 2>/dev/null
	fi
}



########################################
# REMEMBER TO CLEAN UP BEFORE WE PANIC #
########################################
shutdown() {
	[ "$DEBUG" -ge 1 ] && echo "DEBUG: shutting down children." 1>&2
	
	# Safely read PIDs with proper quoting
	if [ -d "$TEMP_DIR" ]; then
		# Read PIDs more efficiently using bash
		CPIDS=""
		for pidfile in "$TEMP_DIR"/*.pid; do
			[ -f "$pidfile" ] && CPIDS="$CPIDS $(<"$pidfile")"
		done 2>/dev/null
		if [ -n "$CPIDS" ]; then
			for CPID in $CPIDS; do 
				[ "$DEBUG" -ge 2 ] && echo "DEBUG: Killing pid: $CPID" 1>&2
				kill -HUP "$CPID" 2>/dev/null || true
			done
		fi
	fi

	# Stop ControlMaster connections if enabled and control persist isn't set
	if [ "$CONTROL_MASTER" = "yes" ] && [ -z "$CONTROL_PERSIST" ]; then
		[ "$DEBUG" -ge 1 ] && echo "DEBUG: closing ControlMaster connections" 1>&2
		if [ -n "$HOSTLIST" ]; then
			for HOST in $HOSTLIST; do
				[ "$DEBUG" -ge 2 ] && echo "DEBUG: closing connection to $HOST" 1>&2
				ssh -O exit -o "ControlPath=$CONTROL_PATH" "$HOST" 2>/dev/null || true
			done
		fi
	fi

	[ "$DEBUG" -ge 2 ] && echo "DEBUG: shutting down ssh-agent" 1>&2
	stop_agent
	[ "$DEBUG" -ge 2 ] && echo "DEBUG: removing temp dir" 1>&2
	destroy_temp
	[ "$DEBUG" -ge 2 ] && echo "DEBUG: done shutting down." 1>&2
	exit 1
}

spew_hostlist() {
	echo "HOSTS RUNNING:"  1>&2
	if [ -d "$TEMP_DIR" ]; then
		# Don't use wildcard expansion directly in the command to prevent errors when no .active files exist
		if ls "$TEMP_DIR"/*.active >/dev/null 2>&1; then
			for active_file in "$TEMP_DIR"/*.active; do
				if [ -f "$active_file" ]; then
					sed 's/^/    /' "$active_file" 2>/dev/null 1>&2
				fi
			done
		else
			echo "    No hosts currently running" 1>&2
		fi
		
		echo "HOSTS REMAINING:"  1>&2
		if [ -f "$TEMP_DIR/hostlist" ]; then
			sed 's/^/    /' "$TEMP_DIR/hostlist" 2>/dev/null 1>&2
		else
			echo "    No hosts remaining" 1>&2
		fi
	else
		echo "    No active hosts (temp directory not found)" 1>&2
	fi
	return 0
}

trap shutdown SIGINT
trap shutdown SIGTERM
trap spew_hostlist SIGQUIT
trap "exit 0" SIGHUP

#############################
# PARSE THE COMMAND OPTIONS #
#############################
while [ "$1" != "" ]; do
        case "$1" in
        ###########
        # OPTIONS #
        ###########
          -A)
                NO_AGENT=1
                shift
                  ;;
          -a)
                FORCE_AGENT=1
                shift
                ;;
          -b)
                BLOCKING=1
                shift
                ;;
          -B)
                # We need to check if this is for blocking (-B) or bind interface (-B <interface>)
                if [ -z "$2" ] || [ "${2:0:1}" = "-" ]; then
                    # No argument or argument starts with '-', assume it's the blocking flag
                    unset BLOCKING
                    shift
                else
                    # Has an argument, assume it's the bind interface
                    BIND_INTERFACE=$2
                    SSH_ARGS="$SSH_ARGS -B $BIND_INTERFACE"
                    shift 2
                fi
                ;;
          -BB)
                # This is explicitly for Blocking without ambiguity
                unset BLOCKING
                shift
                ;;
          -BI)
                # This is explicitly for Bind Interface without ambiguity
                BIND_INTERFACE=$2
                SSH_ARGS="$SSH_ARGS -B $BIND_INTERFACE"
                shift 2
                ;;
          -q)
                QUIET=1
                DEBUG=0
                SSH_VERBOSE="-q"
                shift
                ;;
          -o)
                SSH_ARGS="$SSH_ARGS -o $2"
                shift 2
                ;;
          -u)
                UNIQUE_HOSTS=1
                shift
                ;;
          -U)
                UNIQUE_HOSTS=0
                shift
                ;;
          -l)
                DEFAULT_LOGIN=$2
                shift 2
                ;;
          -L)
                FORCE_LOGIN=$2
                shift 2
                ;;
          -s)
                REMOTE_SHELL=$2
                shift 2
                ;;
          -t*)
                SSH_TIMEOUT="${1#-t}"
                if [ -z "$SSH_TIMEOUT" -a -n "$2" -a "${2#-?*}" = "$2" ] ; then 
                        SSH_TIMEOUT=$2 
                        shift 
                fi 
                if [ "${SSH_TIMEOUT//[^0-9]/}" != "$SSH_TIMEOUT" -o -z "$SSH_TIMEOUT" ] ; then 
                        echo "mussh: Argument should be numeric: -t $SSH_TIMEOUT" 1>&2 
                        exit 1 
                fi 
                shift 
                SSH_ARGS="$SSH_ARGS -o ConnectTimeout=$SSH_TIMEOUT"
                ;;
          -m*)  # -m0 .. -m999
                CONCURRENT="${1#-m}"
                if [ -z "$CONCURRENT" -a -n "$2" -a "${2#-?*}" = "$2" ] ; then 
                        CONCURRENT=$2 
                        shift 
                elif [ -z "$CONCURRENT" ] ; then 
                        CONCURRENT=0 
                fi 
                if [ "${CONCURRENT//[^0-9]/}" != "$CONCURRENT" ] ; then 
                        echo "mussh: Argument should be numeric: -m $CONCURRENT" 1>&2 
                        exit 1 
                fi 
                shift
                ;;
          -d*)
                DEBUG="${1#-d}"
                if [ -z "$DEBUG" -a -n "$2" -a "${2#-?*}" = "$2" ] ; then
                        DEBUG=$2
                        shift
                elif [ -z "$DEBUG" ] ; then
                        DEBUG=1
                fi
                if [ "${DEBUG//[^0-9]/}" != "$DEBUG" ] ; then
                        echo "mussh: Argument should be numeric: -d $DEBUG" 1>&2
                        exit 1
                fi
                shift
                ;;
          -v*)
                TMP_ARG="${1#-v}"
                if [ -z "$TMP_ARG" -a -n "$2" -a "${2#-?*}" = "$2" ] ; then
                        TMP_ARG=$2
                        shift
                elif [ -z "$TMP_ARG" ] ; then
                        TMP_ARG=1
                fi
                if [ "${TMP_ARG//[^0-9]/}" != "$TMP_ARG" ] ; then
                        echo "mussh: Argument should be numeric: -v $TMP_ARG" 1>&2
                        exit 1
                elif [ "${TMP_ARG//[^0-3]/}" != "$TMP_ARG" ] ; then
                        echo "mussh: Argument should be between 0 and 3: -v $TMP_ARG" 1>&2
                        exit 1
                fi
                SSH_VERBOSE="-v"
                [ "$TMP_ARG" -ge 2 ] && SSH_VERBOSE="$SSH_VERBOSE -v"
                [ "$TMP_ARG" -ge 3 ] && SSH_VERBOSE="$SSH_VERBOSE -v"
                [ "$TMP_ARG" -eq 0 ] && SSH_VERBOSE="-q"
                shift
                ;;
          -V)
                echo "Version: $MUSSH_VERSION"
                exit
                  ;;
          -P)
                SSH_ARGS="$SSH_ARGS -o PasswordAuthentication=no"
                shift
                  ;;
          -E)
                SSH_LOG_FILE=$2
                SSH_ARGS="$SSH_ARGS -E $SSH_LOG_FILE"
                shift 2
                  ;;
          -W)
                FORWARD_HOSTPORT=$2
                SSH_ARGS="$SSH_ARGS -W $FORWARD_HOSTPORT"
                shift 2
                  ;;
          -CM)
                CONTROL_MASTER="yes"
                SSH_ARGS="$SSH_ARGS -o ControlMaster=yes"
                shift
                  ;;
          -CP)
                CONTROL_PERSIST=$2
                SSH_ARGS="$SSH_ARGS -o ControlPersist=$CONTROL_PERSIST"
                shift 2
                  ;;
          -S)
                CONTROL_PATH=$2
                SSH_ARGS="$SSH_ARGS -S $CONTROL_PATH"
                shift 2
                  ;;
          -T)
                IDENTITY_AGENT=$2
                SSH_ARGS="$SSH_ARGS -o IdentityAgent=$IDENTITY_AGENT"
                shift 2
                  ;;
          -HKH)
                HASH_KNOWN_HOSTS="yes"
                SSH_ARGS="$SSH_ARGS -o HashKnownHosts=yes"
                shift
                  ;;
          -VHD)
                VERIFY_HOST_DNS="yes"
                SSH_ARGS="$SSH_ARGS -o VerifyHostKeyDNS=yes"
                shift
                  ;;
          --help)
                # print help text
                echo "$USAGE"
                echo "$HELPTEXT"
                exit 
                ;;
          -i)
                # Load the identity file in ssh-agent 
                  while [ "$2" != "" -a "${2#-}" = "$2" ] ; do
                        IDENT="$IDENT $2"
                        shift
                done
                shift
                ;;
        ##############
        # PROXY ARGS #
        ##############
          -p)
                PROXY=$2
                SSH_ARGS="$SSH_ARGS -o ForwardAgent=yes"
                shift 2
                  ;;
          -po)
                PROXY_SSH_ARGS="$PROXY_SSH_ARGS -o $2"
                shift 2
                  ;;
          -J)
                JUMP_HOST=$2
                SSH_ARGS="$SSH_ARGS -o ProxyJump=$JUMP_HOST"
                shift 2
                  ;;
        #############
        # HOST ARGS #
        #############
          -h)
                # Add support for netgroups with @netgroup format
                while [ "$2" != "" -a "${2#-?*}" = "$2" ] ; do
                    if [[ "$2" == @* ]]; then
                        # This is a netgroup, expand it
                        NETGROUP="${2#@}"
                        [ "$DEBUG" -ge 1 ] && echo "DEBUG: Expanding netgroup $NETGROUP" 1>&2
                        # Get hosts from netgroup (getent netgroup)
                        NETGROUP_HOSTS=$(getent netgroup "$NETGROUP" 2>/dev/null | sed -e 's/^[^(]*(//' -e 's/)$//' -e 's/([^,]*,\([^,]*\),[^)]*)/\1/g')
                        if [ -n "$NETGROUP_HOSTS" ]; then
                            for NETGROUP_HOST in $NETGROUP_HOSTS; do
                                HOSTLIST="$NETGROUP_HOST
$HOSTLIST"
                            done
                        else
                            echo "WARNING: Netgroup $NETGROUP not found or empty" 1>&2
                        fi
                    elif [[ "$2" == *\** || "$2" == *\?* ]]; then
                        # This is a wildcard pattern, expand it
                        [ "$DEBUG" -ge 1 ] && echo "DEBUG: Expanding wildcard pattern $2" 1>&2
                        
                        # Create a list of potential hosts from known_hosts and ssh config
                        EXPANDED_HOSTS=""
                        
                        # Check known_hosts file
                        if [ -f ~/.ssh/known_hosts ]; then
                            KNOWN_HOSTS=$(cut -d ' ' -f 1 ~/.ssh/known_hosts 2>/dev/null | cut -d ',' -f 1 | grep -v '^|' | sed 's/\[//g;s/\]:[0-9]*//g')
                            # Find hosts matching the pattern
                            for h in $KNOWN_HOSTS; do
                                # Use case insensitive pattern matching with bash
                                if [[ $h == $2 ]]; then
                                    EXPANDED_HOSTS="$EXPANDED_HOSTS $h"
                                fi
                            done
                        fi
                        
                        # Check ssh config file
                        if [ -f ~/.ssh/config ]; then
                            CONFIG_HOSTS=$(grep -i "^Host " ~/.ssh/config 2>/dev/null | awk '{print $2}' | grep -v "[*?]")
                            # Find hosts matching the pattern
                            for h in $CONFIG_HOSTS; do
                                # Use case insensitive pattern matching with bash
                                if [[ $h == $2 ]]; then
                                    EXPANDED_HOSTS="$EXPANDED_HOSTS $h"
                                fi
                            done
                        fi
                        
                        # If we found any matches, add them
                        if [ -n "$EXPANDED_HOSTS" ]; then
                            [ "$DEBUG" -ge 1 ] && echo "DEBUG: Expanded to: $EXPANDED_HOSTS" 1>&2
                            for h in $EXPANDED_HOSTS; do
                                HOSTLIST="$h
$HOSTLIST"
                            done
                        else
                            echo "WARNING: No hosts found matching pattern $2" 1>&2
                        fi
                    else
                        # Regular host
                        HOSTLIST="$2
$HOSTLIST"
                    fi
                    shift
                done
                shift 
                  ;;
          -H)
                while [ "$2" != "" -a "${2#-?*}" = "$2" ] ; do
                        HOSTFILE="$2"
                        if [ ! -e "$HOSTFILE" -a "$HOSTFILE" != "-" ] ; then
                                echo "mussh: Host file '$HOSTFILE' does not exist!" 1>&2
                                exit 1
                        fi
                        # More efficient file processing with redirection instead of cat
                        if [ "$HOSTFILE" = "-" ]; then
                            # Handle stdin special case
                            NEW_HOSTS="$(sed -e 's/#.*//' | grep -E -v "^ *$")"
                        else
                            # Regular file processing
                            NEW_HOSTS="$(sed -e 's/#.*//' "$HOSTFILE" | grep -E -v "^ *$")"
                        fi
                        HOSTLIST="$NEW_HOSTS
$HOSTLIST"
                        shift
                done
                shift 
                ;;
          -n)
                # Dedicated netgroup expansion option
                NETGROUP=$2
                [ "$DEBUG" -ge 1 ] && echo "DEBUG: Expanding netgroup $NETGROUP" 1>&2
                NETGROUP_HOSTS=$(getent netgroup "$NETGROUP" 2>/dev/null | sed -e 's/^[^(]*(//' -e 's/)$//' -e 's/([^,]*,\([^,]*\),[^)]*)/\1/g')
                if [ -z "$NETGROUP_HOSTS" ]; then
                    echo "WARNING: Netgroup $NETGROUP not found or empty" 1>&2
                    shift 2
                    continue
                fi
                for NETGROUP_HOST in $NETGROUP_HOSTS; do
                    HOSTLIST="$NETGROUP_HOST
$HOSTLIST"
                done
                shift 2
                ;;
        ################
        # COMMAND ARGS #
        ################
          -c)
                THESCRIPT="$THESCRIPT
$2"
                #set "" ; shift
                shift 2
                ;;
          -C)
                while [ "$2" != "" -a "${2#-?*}" = "$2" ] ; do
                        SCRIPTFILE="$2"
                          if [ ! -e "$SCRIPTFILE" -a "$SCRIPTFILE" != "-" ] ; then
                                echo "mussh: Script File '$SCRIPTFILE' does not exist!" 1>&2
                                exit 1
                        fi
                        # More efficient script file processing with redirection
                        if [ "$SCRIPTFILE" = "-" ]; then
                            # Handle stdin special case - read from stdin
                            # Read from stdin more efficiently
                            SCRIPT_CONTENT="$(< /dev/stdin)"
                        else
                            # Regular file processing - read from file
                            SCRIPT_CONTENT="$(< "$SCRIPTFILE")"
                        fi
                        THESCRIPT="$THESCRIPT
$SCRIPT_CONTENT"
                        shift
                done
                shift
                ;;
          *)
                echo "mussh: invalid command - \"$1\"" 1>&2
                echo "$USAGE" 1>&2
                exit 1
                ;;
        esac
done

#####################
# EXPRESS VERBOSITY #
#####################
[ "$DEBUG" -ge 1 ] && echo "DEBUG LEVEL: $DEBUG" 1>&2
[ "$DEBUG" -ge 1 ] && echo "SSH DEBUG LEVEL: $SSH_VERBOSE" 1>&2

#####################
# CLEAN UP HOSTLIST #
#####################
# Clean up hostlist more efficiently
HOSTLIST=$(printf '%s\n' "$HOSTLIST" | sed -e 's/#.*//' | grep -E -v "^ *$" )

if [ "$FORCE_LOGIN" != "" ] ; then
	[ "$DEBUG" -ge 1 ] && echo "DEBUG: FORCE_LOGIN: $FORCE_LOGIN" 1>&2
	HOSTLIST=$(echo "$HOSTLIST" | sed -e "s/^\(.*@\)\{0,1\}\([^@]*\)\$/$FORCE_LOGIN@\2/")
elif [ "$DEFAULT_LOGIN" != "" ] ; then
	[ "$DEBUG" -ge 1 ] && echo "DEBUG: DEFUALT_LOGIN: $DEFAULT_LOGIN" 1>&2
	HOSTLIST=$(echo "$HOSTLIST" | sed -e "s/^\([^@]*\)\$/$DEFAULT_LOGIN@\1/")
fi
[ $UNIQUE_HOSTS -ge 1 ] && HOSTLIST=$(echo "$HOSTLIST" | sort -uf )


################
# CHECK SYNTAX #
################
if [ "$HOSTLIST" = "" ] ; then
        echo "mussh: ERROR: You must supply at least one host!" 1>&2
        echo "$USAGE" 1>&2
        exit 1
fi

###################################
# DEFAULT TO STDIN IF NO COMMANDS #
###################################
if [ "$THESCRIPT" = "" ] ; then
        echo "Enter your script here.  End with single \".\" or EOF." 1>&2
        while read THISLINE
        do 
                if [ "$THISLINE" = "." ] ; then
                        break
                fi
        THESCRIPT="$THESCRIPT
$THISLINE"
        done
fi

###################################################
# INFINITE CONCURRENCY IS REALLY JUST ALL AT ONCE #
###################################################
# Count hosts more efficiently with bash parameter expansion
set -- $HOSTLIST
COUNT_HOSTS=$#
if [ $CONCURRENT -eq 0 ] || [ $CONCURRENT -gt $COUNT_HOSTS ] ; then
       CONCURRENT=$COUNT_HOSTS
       [ "$DEBUG" -ge 1 ] && echo "DEBUG: setting concurrency (-m) to $CONCURRENT (all hosts)" 1>&2
fi
[ "$DEBUG" -ge 1 ] && echo "DEBUG: Concurrency: $CONCURRENT" 1>&2

############################
# CONFIGURE CONTROLMASTER  #
############################
if [ "$CONTROL_MASTER" = "yes" ] && [ -z "$CONTROL_PATH" ]; then
    # Set default control path if ControlMaster is enabled but no path specified
    CONTROL_PATH="$TEMP_DIR/control-%h-%p-%r"
    SSH_ARGS="$SSH_ARGS -o ControlPath=$CONTROL_PATH"
fi

#################################
# ADD SSH VERBOSITY TO SSH ARGS #
#################################
if [ -n "$SSH_VERBOSE" ]; then
    SSH_ARGS="$SSH_VERBOSE $SSH_ARGS"
fi

############################
# PRINT VERBOSE DEBUG INFO #
############################
if [ "$DEBUG" -ge 1 ] ; then
	echo "DEBUG: DEBUG LEVEL: $DEBUG" 1>&2
	echo "DEBUG: SSH DEBUG LEVEL: $SSH_VERBOSE" 1>&2
fi
if [ "$DEBUG" -ge 2 ] ; then
        echo "DEBUG: HOSTLIST: " $HOSTLIST 1>&2
        echo "DEBUG: THE SCRIPT: $THESCRIPT" 1>&2
        echo "DEBUG: SSH ARGS: $SSH_ARGS" 1>&2
        [ -n "$JUMP_HOST" ] && echo "DEBUG: JUMP HOST: $JUMP_HOST" 1>&2
        [ -n "$BIND_INTERFACE" ] && echo "DEBUG: BIND INTERFACE: $BIND_INTERFACE" 1>&2
        [ -n "$SSH_LOG_FILE" ] && echo "DEBUG: SSH LOG FILE: $SSH_LOG_FILE" 1>&2
        [ -n "$CONTROL_MASTER" ] && echo "DEBUG: CONTROL MASTER: $CONTROL_MASTER" 1>&2
        [ -n "$CONTROL_PATH" ] && echo "DEBUG: CONTROL PATH: $CONTROL_PATH" 1>&2
        [ -n "$CONTROL_PERSIST" ] && echo "DEBUG: CONTROL PERSIST: $CONTROL_PERSIST" 1>&2
        [ -n "$IDENTITY_AGENT" ] && echo "DEBUG: IDENTITY AGENT: $IDENTITY_AGENT" 1>&2
        [ -n "$FORWARD_HOSTPORT" ] && echo "DEBUG: FORWARD HOSTPORT: $FORWARD_HOSTPORT" 1>&2
        [ -n "$HASH_KNOWN_HOSTS" ] && echo "DEBUG: HASH KNOWN HOSTS: $HASH_KNOWN_HOSTS" 1>&2
        [ -n "$VERIFY_HOST_DNS" ] && echo "DEBUG: VERIFY HOST DNS: $VERIFY_HOST_DNS" 1>&2
fi

############################
# LOAD SSH-AGENT WITH KEYS #
############################
if [ "$NO_AGENT" = "1" ] ; then
        [ "$DEBUG" -ge 1 ] && echo "DEBUG: Not using ssh-agent" 1>&2
elif [ "$IDENT" != "" ] ; then
        start_agent
        load_keys "$IDENT"
elif [ ! -f "$HOME/.ssh/identity" -a ! -f "$HOME/.ssh/id_dsa" ]  ; then
        [ "$DEBUG" -ge 1 ] && echo "DEBUG: No identity file found.  Skipping agent."
else
        start_agent 
        load_keys "$IDENT"
fi
#echo

###################
# CREATE TEMP DIR #
###################
create_temp

########################
# EXECUTE THE COMMANDS #
########################
if [ -z "$CONCURRENT" ] ; then
CONCURRENT=1
fi

if [ "$PROXY" != "" ] ; then
        proxy_connect

# Don't background process when we're only doing one at a time
#elif [ -z "$CONCURRENT" -o "$CONCURRENT" = 1 ] ; then
#        set $HOSTLIST
#        while [ "$1" != "" ] ; do
#                HOST="$1"
#                [ "$DEBUG" -ge 1 ] && echo "DEBUG: CONNECT $HOST" 1>&2
#		shift
#		ssh_connect 
#	done
else
# Fork $CONCURRENT children
	set_hostlist
	CHILDNUM=1
	while [ $CHILDNUM -le $CONCURRENT ] ; do 
		run_child $CHILDNUM &
		[ "$DEBUG" -ge 2 ] && echo "DEBUG: FORKED CHILD #$CHILDNUM with pid $!" 1>&2
		rm -f "$TEMP_DIR/$CHILDNUM.pid"
		echo $! > "$TEMP_DIR/$CHILDNUM.pid"
		(( CHILDNUM++ ))
        done
	wait
# since trap causes waits to stop waiting with a return value >128
# We need to check that we really meant to stop waiting.
	RETVAL=$?
	while [ "$RETVAL" -gt 128 ] ; do
		[ "$DEBUG" -ge 2 ] && echo "DEBUG: wait returned with a value of $RETVAL" 1>&2
		DO_WAIT=0
		# Read PIDs more efficiently
		for pidfile in "$TEMP_DIR"/*.pid; do
			[ -f "$pidfile" ] || continue
			CPID=$(<"$pidfile")
			# More portable process checking that works on Linux, macOS, BSD, etc.
			if kill -0 "$CPID" 2>/dev/null ; then 
				DO_WAIT=1
				[ "$DEBUG" -ge 2 ] && echo "DEBUG: $CPID is still running." 1>&2
			fi
		done 2>/dev/null
		[ "$DO_WAIT" = 0 ] && break
		wait
		RETVAL=$?
	done
fi

############
# CLEAN UP #
############
destroy_temp
stop_agent